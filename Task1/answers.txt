============================================================
				Часть 1: Разогрев
============================================================
a) Начиная с N = 20 продолжайте увеличивать N с шагом 5 до тех пор, пока вычисление fib_p(N) будет занимать меньше пяти секунд. При каком N это условие перестает выполняться? Почему так происходит?

26> fib:fib_p(20).
6765
27> fib:fib_p(25).
75025
28> fib:fib_p(30).
832040
29> fib:fib_p(35).
9227465
30> fib:fib_p(40).
102334155

fib:fib_p(40) - вычисление заняло более 5 секунд.

fib_p(N) использует обычную рекурсию. При каждом рекурсивном вызове создается и размещаются в стеке набор параметров функции и локальных переменных (+ адрес возврата). Они хранится пока не будут не будет совершен возврат из функции. Стек забивается, время увеличивается.
---------------------------------------
b) Сколько времени тратится на вычисление tail_fib(10000)? Почему?
С помощью функции tc/3 модуля timer, определяем, что на выполнение функция tail_fib(10000) тратиться порядка 4240 мкс. 

38> timer:tc(fib, tail_fib, [10000]).
{16000,
 33644764876431783266621.....}

16000 microseconds.
33644764876431783266621..... - result.

Функция использует хвостовую рекурсию: сохранение параметров и локальных переменных не нужно, адрес возврата уже находится в стеке. 

============================================================
				Часть 2: Квадраты простых чисел и функция Мёбиуса
============================================================

42> mobius:find_square_multiples(3, 50).
48
43> mobius:find_square_multiples(3, 20).
fail
44> mobius:find_square_multiples(4, 30000).
242
45> mobius:find_square_multiples(5, 30000).
844
46> mobius:find_square_multiples(6, 30000).
22020
47> timer:tc(mobius, find_square_multiples, [6,30000]).
{110000,22020}
